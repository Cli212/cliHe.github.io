{"pages":[{"title":"404","text":"","link":"/404.html"}],"posts":[{"title":"随机数","text":"C++里面的随机数和伪随机数真的是令人头大。 遇到的第一个问题是不改变seed的情况下每次rand()的结果都是一样的，于是我再每次rand之前获取一个新种子。虽然仍然是产生的伪随机数，但起码每次调rand函数得到的随机数是不同的了，不知道还有没有更好的更改种子的方法？ 1srand((time(0)+rand())); 更棘手的问题是rand() % n产生小于n的随机数的办法会导致有些余数出现的频率比其他余数大。于是我用了存储桶的策略，因为n*m&lt;=RAND_MAX的所有整数中，m = bucket_size是最大的，那么就可以保证在rand()/bucket_size &lt; n的时候生成的随机数一定可以避免余数出现频率不一的问题，从而合理地产生随机数。 代码如下 12345678910int nrand(int n){ if(n&lt;=0||n&gt;RAND_MAX) throw domain_error(\"Argument to nrand is out of range!\"); srand((time(0)+rand())); const int bucket_size = RAND_MAX/n; int r; do r = rand()/bucket_size; while(r &gt;= n); return r;} Any better ideas ?","link":"/2020/02/12/%E9%9A%8F%E6%9C%BA%E6%95%B0/"},{"title":"C++问答","text":"Q : copy函数拷贝自vector自身的时候无法拷贝最后一个值 A : what?? 123456789 int main(){ vector&lt;double&gt; a; a.push_back(1221.22); a.push_back(12.2323); a.push_back(1); copy(a.begin(),a.end(),back_inserter(a)); for(iter = a.begin();iter != a.end();iter++) cout&lt;&lt;*iter&lt;&lt;endl;} 打印结果","link":"/2020/02/09/C/"},{"title":"Pycharm Professional 2019.2永久激活","text":"免责声明 本教程完全出于个人兴趣爱好，对任何使用者不收取任何费用。 利用本软件所做出的任何软件作品，和本人无关。 该教程仅为学习所用。 补丁链接 步骤如下： 下载补丁文件，讲补丁文件放到pycharm安装目录的bin文件夹下 打开bin文件下的pycharm64.exe.vmoptions，在最后一行添加： -javaagent:../bin/jetbrains-agent.jar 并保存 启动pycharm，跳出激活界面选择Enter Key-&gt;License server，地址填http://jetbrains-license-server 成功✌","link":"/2020/02/12/pycharm-professional-2019-2%E6%B0%B8%E4%B9%85%E6%BF%80%E6%B4%BB/"}],"tags":[{"name":"c++","slug":"c","link":"/tags/c/"}],"categories":[{"name":"Technique","slug":"Technique","link":"/categories/Technique/"}]}