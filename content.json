{"pages":[{"title":"404","text":"","link":"/404.html"}],"posts":[{"title":"随机数","text":"C++里面的随机数和伪随机数真的是令人头大。 遇到的第一个问题是不改变seed的情况下每次rand()的结果都是一样的，于是我再每次rand之前获取一个新种子。虽然仍然是产生的伪随机数，但起码每次调rand函数得到的随机数是不同的了，不知道还有没有更好的更改种子的方法？ 1srand((time(0)+rand())); 更棘手的问题是rand() % n产生小于n的随机数的办法会导致有些余数出现的频率比其他余数大。于是我用了存储桶的策略，因为n*m&lt;=RAND_MAX的所有整数中，m = bucket_size是最大的，那么就可以保证在rand()/bucket_size &lt; n的时候生成的随机数一定可以避免余数出现频率不一的问题，从而合理地产生随机数。 代码如下 12345678910int nrand(int n){ if(n&lt;=0||n&gt;RAND_MAX) throw domain_error(\"Argument to nrand is out of range!\"); srand((time(0)+rand())); const int bucket_size = RAND_MAX/n; int r; do r = rand()/bucket_size; while(r &gt;= n); return r;} Any better ideas ?","link":"/2020/02/12/%E9%9A%8F%E6%9C%BA%E6%95%B0/"},{"title":"C++问答","text":"Q : copy函数拷贝自vector自身的时候无法拷贝最后一个值 A : what?? 123456789 int main(){ vector&lt;double&gt; a; a.push_back(1221.22); a.push_back(12.2323); a.push_back(1); copy(a.begin(),a.end(),back_inserter(a)); for(iter = a.begin();iter != a.end();iter++) cout&lt;&lt;*iter&lt;&lt;endl;} 打印结果","link":"/2020/02/09/C/"},{"title":"First","text":"Hello World!","link":"/2020/02/09/hello/"}],"tags":[{"name":"c++","slug":"c","link":"/tags/c/"}],"categories":[{"name":"Technique","slug":"Technique","link":"/categories/Technique/"}]}