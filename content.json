{"pages":[{"title":"404","text":"","link":"/404.html"}],"posts":[{"title":"随机数","text":"C++里面的随机数和伪随机数真的是令人头大。 遇到的第一个问题是不改变seed的情况下每次rand()的结果都是一样的，于是我再每次rand之前获取一个新种子。虽然仍然是产生的伪随机数，但起码每次调rand函数得到的随机数是不同的了，不知道还有没有更好的更改种子的方法？ 1srand((time(0)+rand())); 更棘手的问题是rand() % n产生小于n的随机数的办法会导致有些余数出现的频率比其他余数大。于是我用了存储桶的策略，因为n*m&lt;=RAND_MAX的所有整数中，m = bucket_size是最大的，那么就可以保证在rand()/bucket_size &lt; n的时候生成的随机数一定可以避免余数出现频率不一的问题，从而合理地产生随机数。 代码如下 12345678910int nrand(int n){ if(n&lt;=0||n&gt;RAND_MAX) throw domain_error(\"Argument to nrand is out of range!\"); srand((time(0)+rand())); const int bucket_size = RAND_MAX/n; int r; do r = rand()/bucket_size; while(r &gt;= n); return r;} Any better ideas ?","link":"/2020/02/12/%E9%9A%8F%E6%9C%BA%E6%95%B0/"},{"title":"C++问答","text":"Q : copy函数拷贝自vector自身的时候无法拷贝最后一个值 A : what?? 123456789 int main(){ vector&lt;double&gt; a; a.push_back(1221.22); a.push_back(12.2323); a.push_back(1); copy(a.begin(),a.end(),back_inserter(a)); for(iter = a.begin();iter != a.end();iter++) cout&lt;&lt;*iter&lt;&lt;endl;} 打印结果","link":"/2020/02/09/C/"},{"title":"赋值与初始化","text":"区分类的赋值和初始化在对类的对象做处理的时候，“=”既可以用来给对象初始化也可以用来给对象赋值，很难区分。确切的说，初始化包括创造一个新的对象，并同时给它一个初始的值，调用的是复制构造函数。而赋值操作是删除旧的值，然后赋给这个对象新的值，调用的是重载后的 “=”操作符函数。 类的默认操作默认析构函数删除一个指针变量时不会释放该指针指向的对象占用的内存空间。 默认构造函数如果成员变量是类的对象实例，那么对他们复制、赋值和删除时会调用想用的类的构造函数、赋值运算符函数或析构函数。 三位一体规则：复制构造函数、析构函数和赋值运算符函数关系十分紧密。 详见P212","link":"/2020/02/15/%E8%B5%8B%E5%80%BC%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"title":"迭代器种类","text":"迭代器的种类 输入迭代器：顺序只读访问，所有的容器迭代器都是输入迭代器。——find函数 输出迭代器：顺序只写访问，不能在对*iter的；两个赋值运算之间执行超过一次的++iter操作，也不能在没有对iter进行递增的情况下对iter进行多次赋值。——copy函数 正向迭代器：顺序读-写访问，一旦处理了一个元素，绝不会再次访问它。所有的标准库容器都满足正向迭代器的要求。——replace函数 双向迭代器：可以按正向或者逆向访问一个容器的元素，所有的标准库容器都支持双向迭代器。——reverse函数 随机访问迭代器：能够随机访问容器中的元素，vector和string的迭代器都是这样的迭代器，而list迭代器则不支持这样的操作。——sort函数","link":"/2020/02/12/%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%A7%8D%E7%B1%BB/"},{"title":"Pycharm Professional 2019.2永久激活","text":"免责声明 本教程完全出于个人兴趣爱好，对任何使用者不收取任何费用。 利用本软件所做出的任何软件作品，和本人无关。 该教程仅为学习所用。 补丁链接 步骤如下： 下载补丁文件，讲补丁文件放到pycharm安装目录的bin文件夹下 打开bin文件下的pycharm64.exe.vmoptions，在最后一行添加： -javaagent:../bin/jetbrains-agent.jar 并保存 启动pycharm，跳出激活界面选择Enter Key-&gt;License server，地址填http://jetbrains-license-server 成功✌","link":"/2020/02/12/pycharm-professional-2019-2%E6%B0%B8%E4%B9%85%E6%BF%80%E6%B4%BB/"}],"tags":[{"name":"c++","slug":"c","link":"/tags/c/"}],"categories":[{"name":"Technique","slug":"Technique","link":"/categories/Technique/"}]}